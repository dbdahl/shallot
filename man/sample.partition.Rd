\name{sample.partition}
\alias{sample.partition}
\alias{print.shallot.samples.raw}
\title{Sample Partitions for the Supplied Partition Distribution}
\description{
  Samples from the supplied partition distribution are collected, with or without parallelization.
}
\usage{
sample.partition(x, n.draws, parallel = TRUE)
\method{print}{shallot.samples.raw}(x, ...)
}
\arguments{
\item{x}{An object of class \code{shallot.distribution} obtained, for example, from the \code{\link{ewens}} function.}
\item{n.draws}{An integer representing the number of samples.}
\item{parallel}{Should sampling be done in parallel by simulatenously using all CPU cores?}
\item{...}{Currently ignored.}
}
\details{
This function brings together everything thus far in the process and calculates the distribution of the number of subsets for each of the given number of samples.  The random element established in the \code{\link{permutation}} function has remained dormant until now, and it is at this stage that the number of subsets for each sample is determined at random.  The output can be altered slightly by whether \var{seed} is not \code{NULL}, by whether \var{parallel} is \code{FALSE}, and rarely by whether \var{reset} is \code{TRUE}.  The output can be altered significantly by whether \var{mcmc.parameters} is \code{NULL}, as this function can only work on certain distribution methods when \var{mcmc.parameters} is not \code{NULL}.

The \code{\link{print.shallot.samples.raw}} function is an internal function that prints a message prompting the user to use the process function to extract the results from collect.
}
\value{
An object of class \code{shallot.samples.raw} storing the various input values given above as well as the number of partitions and the number of subsets for each sample, though the user will have to use the process function to extract the latter two.
}
\note{
The \code{\link{sample.partition}} function is designed to allow an object of class \code{shallot.samples.raw}, the class generated by this very function, to be used as input.  The result is that the samples collected the first time around remain intact, while a new batch of samples is added.
}
\author{David B. Dahl \email{dahl@stat.byu.edu}}
\seealso{
\code{\link{distribution}}
\code{\link{process.partition}}
}
\examples{
\dontrun{
## Demonstrate collect.
data <- Theoph[, c("Wt", "Dose", "Time", "conc", "Subject")]
truth <- as.numeric(levels(data[, ncol(data)]))[data[, ncol(data)]]
distance <- dist(scale(data[, -ncol(data)]))
temperature <- 9.0
temperatureFixed <- TRUE
decay <- decay.exponential(temperature, fixed = temperatureFixed)
attract <- attraction(distance(as.matrix(distance)),
    permutation(n.items = nrow(data), fixed = FALSE), decay)
massValue <- 1.0
massFixed <- TRUE
discount <- discount(0.1, fixed = TRUE)
nSamples <- 500
mass <- mass(massValue, fixed = massFixed)
distribution <- ewens.pitman.attraction(mass, discount, attract)
samples <- collect(distribution, nSamples)
print(samples)
mcmc.parameters <- mcmc.parameters(mass.rw.sd = 0.5, discount.rw.sd = 0.1,
    permutation.grab.size = 10, temperature.rw.sd = 0.5,
    n.iterations.per.sample = 1)
nSamples <- 50
samples <- collect(distribution, nSamples, mcmc.parameters = mcmc.parameters)
print(samples)
}
}

