\name{collect}
\alias{collect}
\alias{print.shallot.samples.raw}
\title{Collect}
\description{
  A function that calculates the distribution of the subsets amongst the number of samples.}
\usage{
collect(x, n.draws = 1000, mcmc.parameters = NULL,
    parallel = TRUE, seed = NULL, reset = FALSE)
\method{print}{shallot.samples.raw}(x, ...)
}
\arguments{
\item{x}{An object of class \code{shallot.distribution}, with the distribution type specified in a subargument to this item.}
\item{n.draws}{An integer representing the number of samples, usually \code{500}.}
\item{mcmc.parameters}{An object of class \code{shallot.mcmc.parameters} specifying the additional variables contained therein.  Defaults to \code{NULL}.}
\item{parallel}{A boolean object indicating whether the samples are parallel.  Defaults to \code{TRUE}.}
\item{seed}{An integer indicating by how much an internal variable called rdg is to be reseeded.  Defaults to \code{NULL}.}
\item{reset}{A boolean object indicating whether to call the \dQuote{take} command from LScala when the distribution is of type \code{shallot.samples.raw}.  Defaults to \code{FALSE}.}
\item{...}{An additional argument, not used.}
}
\details{
This function brings together everything thus far in the process and calculates the distribution of the number of subsets for each of the given number of samples.  The random element established in the \code{\link{permutation}} function has remained dormant until now, and it is at this stage that the number of subsets for each sample is determined at random.  The output can be altered slightly by whether \var{seed} is not \code{NULL}, by whether \var{parallel} is \code{FALSE}, and rarely by whether \var{reset} is \code{TRUE}.  The output can be altered significantly by whether \var{mcmc.parameters} is \code{NULL}, as this function can only work on certain distribution methods when \var{mcmc.parameters} is not \code{NULL}.

The \code{\link{print.shallot.samples.raw}} function is an internal function that prints a message prompting the user to use the process function to extract the results from collect.
}
\value{
An object of class \code{shallot.samples.raw} storing the various input values given above as well as the number of partitions and the number of subsets for each sample, though the user will have to use the process function to extract the latter two.
}
\note{
The collect function does not work on \code{\link{ddcrp}} function when \var{mcmc.parameters} is not \code{NULL}.  An error message is generated.
}
\note{
The \code{\link{collect}} function is designed to allow an object of class \code{shallot.samples.raw}, the class generated by this very function, to be used as input.  The result is that the samples collected the first time around remain intact, while a new batch of samples is added.
}
\author{David B. Dahl \email{dahl@stat.byu.edu}}
\seealso{
\code{\link{mcmc.parameters}}
\code{\link{distribution}}
\code{\link{process}}
}
\examples{
\dontrun{
## Demonstrate collect.
data <- Theoph[, c("Wt", "Dose", "Time", "conc", "Subject")]
truth <- as.numeric(levels(data[, ncol(data)]))[data[, ncol(data)]]
distance <- dist(scale(data[, -ncol(data)]))
temperature <- 9.0
temperatureFixed <- TRUE
decay <- decay.exponential(temperature, fixed = temperatureFixed)
attract <- attraction(distance(as.matrix(distance)),
    permutation(n.items = nrow(data), fixed = FALSE), decay)
massValue <- 1.0
massFixed <- TRUE
discount <- discount(0.1, fixed = TRUE)
nSamples <- 500
mass <- mass(massValue, fixed = massFixed)
distribution <- ewens.pitman.attraction(mass, discount, attract)
samples <- collect(distribution, nSamples)
print(samples)
mcmc.parameters <- mcmc.parameters(mass.rw.sd = 0.5, discount.rw.sd = 0.1,
    permutation.grab.size = 10, temperature.rw.sd = 0.5,
    n.iterations.per.sample = 1)
nSamples <- 50
samples <- collect(distribution, nSamples, mcmc.parameters = mcmc.parameters)
print(samples)
}
}

